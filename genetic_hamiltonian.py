# -*- coding: utf-8 -*-
"""Genetic_Hamiltonian.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17jfdn6WTniY6KRqSDFYU3zVV5GEB4P2p
"""



#SA
import random
import math
import networkx as nx
import matplotlib.pyplot as plt

# Define the graph as an adjacency matrix
graph = [
    [0, 3, 0, 0, 2],
    [3, 0, 4, 0, 0],
    [0, 4, 0, 7, 0],
    [0, 0, 7, 0, 8],
    [2, 0, 0, 8, 0]
]

# Define the number of vertices
num_vertices = len(graph)

def calculate_total_distance(solution):
    total_distance = 0
    for i in range(num_vertices - 1):
        u, v = solution[i], solution[i+1]
        total_distance += graph[u][v]
    total_distance += graph[solution[-1]][solution[0]]  # Add distance from last vertex to starting vertex
    return total_distance


def generate_initial_solution():
    return list(range(num_vertices))

def perturb_solution(solution):
    i, j = random.sample(range(num_vertices), 2)
    solution[i], solution[j] = solution[j], solution[i]
    return solution

def acceptance_probability(old_distance, new_distance, temperature):
    if new_distance < old_distance:
        return 1.0
    return math.exp((old_distance - new_distance) / temperature)

def simulated_annealing(initial_solution, initial_temperature, cooling_rate, num_iterations):
    current_solution = initial_solution
    current_distance = calculate_total_distance(current_solution)
    best_solution = current_solution
    best_distance = current_distance
    temperature = initial_temperature

    for _ in range(num_iterations):
        new_solution = perturb_solution(current_solution)
        new_distance = calculate_total_distance(new_solution)

        if acceptance_probability(current_distance, new_distance, temperature) > random.random():
            current_solution = new_solution
            current_distance = new_distance
            if new_distance < best_distance:
                best_solution = new_solution
                best_distance = new_distance

        temperature *= cooling_rate

    return best_solution, best_distance

# Set parameters for SA
initial_temperature = 1000
cooling_rate = 0.99
num_iterations = 10000

# Generate initial solution
initial_solution = generate_initial_solution()

# Run Simulated Annealing
best_solution, best_distance = simulated_annealing(initial_solution, initial_temperature, cooling_rate, num_iterations)

# Add the starting vertex to the end to form a closed Hamiltonian circuit
best_solution.append(best_solution[0])

print("Best Solution:", best_solution)
print("Best Distance:", best_distance)

# Create a NetworkX graph
G = nx.Graph()
for i in range(num_vertices):
    for j in range(i + 1, num_vertices):
        G.add_edge(i, j, weight=graph[i][j])

# Highlight the path of the best solution
best_path = [(best_solution[i], best_solution[i+1]) for i in range(len(best_solution) - 1)]

# Draw the graph with highlighted path
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=700, font_size=10)
nx.draw_networkx_edges(G, pos, edgelist=best_path, edge_color='red', width=2)
plt.title("Hamiltonian Circuit (Simulated Annealing)")
plt.show()

import random
import math
import networkx as nx
import matplotlib.pyplot as plt

# Define the graph as an adjacency matrix with weights
graph = [
    [0, 3, 0, 0, 2],
    [3, 0, 4, 0, 0],
    [0, 4, 0, 7, 0],
    [0, 0, 7, 0, 8],
    [2, 0, 0, 8, 0]
]

# Define the number of vertices
num_vertices = len(graph)

def calculate_total_distance(solution):
    total_distance = 0
    for i in range(num_vertices - 1):
        u, v = solution[i], solution[i+1]
        total_distance += graph[u][v]
    total_distance += graph[solution[-1]][solution[0]]  # Add distance from last vertex to starting vertex
    return total_distance

def generate_initial_solution():
    return list(range(num_vertices))

def perturb_solution(solution):
    i, j = random.sample(range(num_vertices), 2)
    solution[i], solution[j] = solution[j], solution[i]
    return solution

def acceptance_probability(old_distance, new_distance, temperature):
    if new_distance < old_distance:
        return 1.0
    return math.exp((old_distance - new_distance) / temperature)

def simulated_annealing(initial_solution, initial_temperature, cooling_rate, num_iterations):
    current_solution = initial_solution
    current_distance = calculate_total_distance(current_solution)
    best_solution = current_solution
    best_distance = current_distance
    temperature = initial_temperature

    for _ in range(num_iterations):
        new_solution = perturb_solution(current_solution)
        new_distance = calculate_total_distance(new_solution)

        if acceptance_probability(current_distance, new_distance, temperature) > random.random():
            current_solution = new_solution
            current_distance = new_distance
            if new_distance < best_distance:
                best_solution = new_solution
                best_distance = new_distance

        temperature *= cooling_rate

    return best_solution, best_distance

# Set parameters for SA
initial_temperature = 1000
cooling_rate = 0.99
num_iterations = 10000

# Generate initial solution
initial_solution = generate_initial_solution()

# Run Simulated Annealing
best_solution, best_distance = simulated_annealing(initial_solution, initial_temperature, cooling_rate, num_iterations)

# Add the starting vertex to the end to form a closed Hamiltonian circuit
best_solution.append(best_solution[0])

print("Best Solution:", best_solution)
print("Best Distance:", best_distance)

# Create a NetworkX graph
G = nx.Graph()
for i in range(num_vertices):
    for j in range(i + 1, num_vertices):
        G.add_edge(i, j, weight=graph[i][j])

# Highlight the path of the best solution
best_path = [(best_solution[i], best_solution[i+1]) for i in range(len(best_solution) - 1)]

# Draw the graph with weights and highlighted path
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=700, font_size=10)
nx.draw_networkx_edges(G, pos, edgelist=best_path, edge_color='red', width=2)
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
plt.title("Hamiltonian Circuit (Simulated Annealing)")
plt.show()

import random
import math
import networkx as nx
import matplotlib.pyplot as plt

# Define the graph as an adjacency matrix with weights
graph = [
    [0, 3, 5, 0, 2],
    [3, 0, 4, 6, 0],
    [5, 4, 0, 7, 0],
    [0, 6, 7, 0, 8],
    [2, 0, 0, 8, 0]
]

# Define the number of vertices
num_vertices = len(graph)

# Create a NetworkX graph
G = nx.Graph()

# Add edges with weights greater than zero
for i in range(num_vertices):
    for j in range(i + 1, num_vertices):
        if graph[i][j] > 0:
            G.add_edge(i, j, weight=graph[i][j])

def calculate_total_distance(solution):
    total_distance = 0
    for i in range(num_vertices - 1):
        u, v = solution[i], solution[i+1]
        total_distance += graph[u][v]
    total_distance += graph[solution[-1]][solution[0]]  # Add distance from last vertex to starting vertex
    return total_distance

def generate_initial_solution():
    return list(range(num_vertices))

def perturb_solution(solution):
    i, j = random.sample(range(num_vertices), 2)
    solution[i], solution[j] = solution[j], solution[i]
    return solution

def acceptance_probability(old_distance, new_distance, temperature):
    if new_distance < old_distance:
        return 1.0
    return math.exp((old_distance - new_distance) / temperature)

def simulated_annealing(initial_solution, initial_temperature, cooling_rate, num_iterations):
    current_solution = initial_solution
    current_distance = calculate_total_distance(current_solution)
    best_solution = current_solution
    temperature = initial_temperature

    for _ in range(num_iterations):
        new_solution = perturb_solution(current_solution)
        new_distance = calculate_total_distance(new_solution)

        if acceptance_probability(current_distance, new_distance, temperature) > random.random():
            current_solution = new_solution
            current_distance = new_distance
            if new_distance < calculate_total_distance(best_solution):
                best_solution = new_solution

        temperature *= cooling_rate

    return best_solution

# Set parameters for SA
initial_temperature = 1000
cooling_rate = 0.99
num_iterations = 10000

# Generate initial solution
initial_solution = generate_initial_solution()

# Run Simulated Annealing
best_solution = simulated_annealing(initial_solution, initial_temperature, cooling_rate, num_iterations)

# Add the starting vertex to the end to form a closed Hamiltonian circuit
best_solution.append(best_solution[0])

print("Best Solution:", best_solution)

# Highlight the path of the best solution
best_path = [(best_solution[i], best_solution[i+1]) for i in range(len(best_solution) - 1)]

# Draw the graph with weights and highlighted path
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=700, font_size=10)
nx.draw_networkx_edges(G, pos, edgelist=best_path, edge_color='red', width=2)
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
plt.title("Hamiltonian Circuit (Simulated Annealing)")
plt.show()

#GA
import random
import networkx as nx
import matplotlib.pyplot as plt

# Define graph and its weights
graph = {
    'A': {'B': 2, 'C': 3, 'D': 4},
    'B': {'A': 2, 'C': 2, 'D': 3},
    'C': {'A': 3, 'B': 2, 'D': 1},
    'D': {'A': 4, 'B': 3, 'C': 1}
}

# Genetic Algorithm Parameters
population_size = 50
mutation_rate = 0.1
num_generations = 100

# Function to generate initial population
def generate_initial_population(graph, population_size):
    population = []
    vertices = list(graph.keys())
    for _ in range(population_size):
        chromosome = random.sample(vertices, len(vertices))
        population.append(chromosome)
    return population

# Function to calculate fitness of a chromosome
def calculate_fitness(chromosome, graph):
    fitness = 0
    for i in range(len(chromosome) - 1):
        source, target = chromosome[i], chromosome[i + 1]
        fitness += graph[source][target]  # Add weight of the edge
    fitness += graph[chromosome[-1]][chromosome[0]]  # Add weight of the last edge back to the starting vertex
    return fitness

# Function to perform selection using tournament selection
def selection(population, graph):
    selected = []
    for _ in range(len(population)):
        tournament = random.sample(population, 5)  # Tournament size of 5
        selected.append(max(tournament, key=lambda x: calculate_fitness(x, graph)))
    return selected

# Function to perform crossover using order crossover (OX)
def crossover(parent1, parent2):
    child = [None] * len(parent1)
    start, end = sorted(random.sample(range(len(parent1)), 2))
    for i in range(start, end + 1):
        child[i] = parent1[i]
    remaining = [gene for gene in parent2 if gene not in child]
    index = 0
    for i in range(len(parent1)):
        if child[i] is None:
            child[i] = remaining[index]
            index += 1
    return child

# Function to perform mutation by swapping two genes
def mutate(chromosome):
    if random.random() < mutation_rate:
        idx1, idx2 = random.sample(range(len(chromosome)), 2)
        chromosome[idx1], chromosome[idx2] = chromosome[idx2], chromosome[idx1]
    return chromosome

# Function to visualize the graph with the Hamiltonian circuit including edge weights
def visualize_graph_with_hamiltonian_circuit(graph, hamiltonian_path):
    G = nx.Graph()
    G.add_nodes_from(graph.keys())
    for node, neighbors in graph.items():
        for neighbor, weight in neighbors.items():
            G.add_edge(node, neighbor, weight=weight)  # Add weight to the edge

    pos = nx.spring_layout(G)
    nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)

    for edge in G.edges():
        weight = G.get_edge_data(edge[0], edge[1])['weight']
        plt.text((pos[edge[0]][0] + pos[edge[1]][0]) / 2, (pos[edge[0]][1] + pos[edge[1]][1]) / 2 + 0.05, str(weight),
                 horizontalalignment='center', verticalalignment='center', fontsize=14, color='black')

    hamiltonian_edges = [(hamiltonian_path[i], hamiltonian_path[i + 1]) for i in range(len(hamiltonian_path) - 1)]
    hamiltonian_edges.append((hamiltonian_path[-1], hamiltonian_path[0]))  # Closing edge
    nx.draw_networkx_edges(G, pos, edgelist=hamiltonian_edges, width=2.5, edge_color='red')

    plt.title('Graph with Highlighted Hamiltonian Circuit using GA Algorithm')
    plt.show()
# Main Genetic Algorithm Loop
population = generate_initial_population(graph, population_size)
for generation in range(num_generations):
    population = selection(population, graph)
    offspring = []
    for _ in range(population_size):
        parent1, parent2 = random.sample(population, 2)
        child = crossover(parent1, parent2)
        child = mutate(child)
        offspring.append(child)
    population = offspring

# Select the best chromosome from the final population
best_chromosome = max(population, key=lambda x: calculate_fitness(x, graph))

# Find the index of the first vertex in the Hamiltonian circuit
first_vertex_index = best_chromosome.index(min(best_chromosome))

# Print the Hamiltonian circuit with edge weights
rearranged_chromosome_with_end = rearranged_chromosome + [rearranged_chromosome[0]]
print("Hamiltonian Circuit Found:", rearranged_chromosome_with_end)
total_weight = 0
for i in range(len(rearranged_chromosome) - 1):
    source, target = rearranged_chromosome[i], rearranged_chromosome[i + 1]
    weight = graph[source][target]
    total_weight += weight
    print(f"Edge: {source} -> {target}, Weight: {weight}")
source, target = rearranged_chromosome[-1], rearranged_chromosome[0]
weight = graph[source][target]
total_weight += weight
print(f"Edge: {source} -> {target}, Weight: {weight}")

# Visualize the graph with the Hamiltonian circuit found
visualize_graph_with_hamiltonian_circuit(graph, rearranged_chromosome_with_end)

import random
import networkx as nx
import matplotlib.pyplot as plt

# Define graph and its weights
graph = {
    'A': {'B': 2, 'C': 3, 'D': 4},
    'B': {'A': 2, 'C': 2, 'D': 3},
    'C': {'A': 3, 'B': 2, 'D': 1},
    'D': {'A': 4, 'B': 3, 'C': 1}
}

# Genetic Algorithm Parameters
population_size = 50
mutation_rate = 0.1
num_generations = 100

# Function to generate initial population
def generate_initial_population(graph, population_size):
    population = []
    vertices = list(graph.keys())
    for _ in range(population_size):
        chromosome = random.sample(vertices, len(vertices))
        population.append(chromosome)
    return population

# Function to calculate fitness of a chromosome
def calculate_fitness(chromosome, graph):
    fitness = 0
    for i in range(len(chromosome) - 1):
        source, target = chromosome[i], chromosome[i + 1]
        fitness += graph[source][target]  # Add weight of the edge
    fitness += graph[chromosome[-1]][chromosome[0]]  # Add weight of the last edge back to the starting vertex
    return fitness

# Function to perform selection using tournament selection
def selection(population, graph):
    selected = []
    for _ in range(len(population)):
        tournament = random.sample(population, 5)  # Tournament size of 5
        selected.append(max(tournament, key=lambda x: calculate_fitness(x, graph)))
    return selected

# Function to perform crossover using order crossover (OX)
def crossover(parent1, parent2):
    child = [None] * len(parent1)
    start, end = sorted(random.sample(range(len(parent1)), 2))
    for i in range(start, end + 1):
        child[i] = parent1[i]
    remaining = [gene for gene in parent2 if gene not in child]
    index = 0
    for i in range(len(parent1)):
        if child[i] is None:
            child[i] = remaining[index]
            index += 1
    return child

# Function to perform mutation by swapping two genes
def mutate(chromosome):
    if random.random() < mutation_rate:
        idx1, idx2 = random.sample(range(len(chromosome)), 2)
        chromosome[idx1], chromosome[idx2] = chromosome[idx2], chromosome[idx1]
    return chromosome

# Function to visualize the graph with the Hamiltonian circuit including edge weights
def visualize_graph_with_hamiltonian_circuit(graph, hamiltonian_path):
    G = nx.Graph()
    G.add_nodes_from(graph.keys())
    for node, neighbors in graph.items():
        for neighbor, weight in neighbors.items():
            G.add_edge(node, neighbor, weight=weight)  # Add weight to the edge

    pos = nx.spring_layout(G)
    nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)

    for edge in G.edges():
        weight = G.get_edge_data(edge[0], edge[1])['weight']
        plt.text((pos[edge[0]][0] + pos[edge[1]][0]) / 2, (pos[edge[0]][1] + pos[edge[1]][1]) / 2 + 0.05, str(weight),
                 horizontalalignment='center', verticalalignment='center', fontsize=14, color='black')

    hamiltonian_edges = [(hamiltonian_path[i], hamiltonian_path[i + 1]) for i in range(len(hamiltonian_path) - 1)]
    hamiltonian_edges.append((hamiltonian_path[-1], hamiltonian_path[0]))  # Closing edge
    nx.draw_networkx_edges(G, pos, edgelist=hamiltonian_edges, width=2.5, edge_color='red')

    plt.title('Graph with Highlighted Hamiltonian Circuit using GA Algorithm')
    plt.show()

# Main Genetic Algorithm Loop
population = generate_initial_population(graph, population_size)
for generation in range(num_generations):
    population = selection(population, graph)
    offspring = []
    for _ in range(population_size):
        parent1, parent2 = random.sample(population, 2)
        child = crossover(parent1, parent2)
        child = mutate(child)
        offspring.append(child)
    population = offspring

# Select the best chromosome from the final population
best_chromosome = max(population, key=lambda x: calculate_fitness(x, graph))

# Find the index of the first vertex in the Hamiltonian circuit
first_vertex_index = best_chromosome.index(min(best_chromosome))

# Rearrange the chromosome to start from the first vertex
rearranged_chromosome = best_chromosome[first_vertex_index:] + best_chromosome[:first_vertex_index]

# Print the Hamiltonian circuit with edge weights
rearranged_chromosome_with_end = rearranged_chromosome + [rearranged_chromosome[0]]
print("Hamiltonian Circuit Found:", rearranged_chromosome_with_end)
total_weight = 0
for i in range(len(rearranged_chromosome) - 1):
    source, target = rearranged_chromosome[i], rearranged_chromosome[i + 1]
    weight = graph[source][target]
    total_weight += weight
    print(f"Edge: {source} -> {target}, Weight: {weight}")
source, target = rearranged_chromosome[-1], rearranged_chromosome[0]
weight = graph[source][target]
total_weight += weight
print(f"Edge: {source} -> {target}, Weight: {weight}")

# Visualize the graph with the Hamiltonian circuit found
visualize_graph_with_hamiltonian_circuit(graph, rearranged_chromosome_with_end)



import random
import matplotlib.pyplot as plt

# Genetic Algorithm Parameters
population_size = 50
num_generations = 50
mutation_rate = 0.1

# Define the graph
graph = {
    'A': {'B': True, 'C': True, 'D': True},
    'B': {'A': True, 'C': True, 'D': True},
    'C': {'A': True, 'B': True, 'D': True},
    'D': {'A': True, 'B': True, 'C': True}
}

# Function to generate initial population
def generate_initial_population(population_size, graph):
    return [random.sample(list(graph.keys()), len(graph)) for _ in range(population_size)]

# Function to calculate the space complexity for each generation
def calculate_space_complexity(generation):
    # Generate initial population
    population = generate_initial_population(population_size, graph)
    space_complexity = population_size * len(population[0])  # Initial population storage

    # Selection, Crossover, Mutation, Replacement
    for _ in range(generation):
        selected_population = population  # No additional space required for selection
        offspring = []
        while len(offspring) < population_size:
            parent1, parent2 = random.sample(selected_population, 2)
            child1, child2 = crossover(parent1, parent2)
            child1 = mutate(child1, mutation_rate)
            child2 = mutate(child2, mutation_rate)
            offspring.extend([child1, child2])
        population = offspring
        space_complexity += population_size * len(population[0])  # Space for new population

    return space_complexity

# Calculate space complexity for each generation
space_complexity_data = [calculate_space_complexity(generation) for generation in range(num_generations)]

# Plot the space complexity graph
plt.plot(range(num_generations), space_complexity_data)
plt.xlabel('Generation')
plt.ylabel('Space Complexity')
plt.title('Space Complexity of Genetic Algorithm for Hamiltonian Circuit')
plt.show()

import random
import matplotlib.pyplot as plt

# SA Algorithm Parameters
num_iterations = 50

# Define the graph
graph = {
    'A': {'B': True, 'C': True, 'D': True},
    'B': {'A': True, 'C': True, 'D': True},
    'C': {'A': True, 'B': True, 'D': True},
    'D': {'A': True, 'B': True, 'C': True}
}

# Function to generate a random solution
def generate_random_solution(graph):
    return random.sample(list(graph.keys()), len(graph))

# Function to calculate the space complexity for each iteration
def calculate_space_complexity(iteration):
    # Generate a random solution
    solution = generate_random_solution(graph)
    space_complexity = len(solution)  # Space for storing the solution

    # Annealing Process
    for _ in range(iteration):
        neighbor_solution = generate_random_solution(graph)  # Generate a neighboring solution
        space_complexity += len(neighbor_solution)  # Space for storing the neighbor solution

    return space_complexity

# Calculate space complexity for each iteration
space_complexity_data = [calculate_space_complexity(iteration) for iteration in range(num_iterations)]
# Plot the space complexity graph
plt.plot(range(num_generations), space_complexity_data)
plt.xlabel('Generation')
plt.ylabel('Space Complexity')
plt.title('Space Complexity of Genetic Algorithm for Hamiltonian Circuit')
plt.ylim(0, 200)
plt.show()

import random
import math
import matplotlib.pyplot as plt

def simulated_annealing_space_complexity(num_vertices):
    # Space complexity for adjacency matrix: O(V^2)
    # Space complexity for solution representation: O(V)
    space_complexity = num_vertices**2 + num_vertices
    return space_complexity

# Define the range of problem sizes (number of vertices)
problem_sizes = list(range(5, 101, 5))  # From 5 to 100 vertices, incrementing by 5

# Calculate space complexity for each problem size
space_complexities = [simulated_annealing_space_complexity(num_vertices) for num_vertices in problem_sizes]

# Plotting the space complexity graph
plt.figure(figsize=(10, 6))
plt.plot(problem_sizes, space_complexities, marker='o', linestyle='-', color='b')
plt.title('Space Complexity of Simulated Annealing for Hamiltonian Circuit')
plt.xlabel('Number of Vertices')
plt.ylabel('Space Complexity')
plt.grid(True)
plt.tight_layout()
plt.show()

import random
import matplotlib.pyplot as plt

def initialize_population(population_size, num_vertices):
    # Initialize population with random permutations of vertices
    population = []
    for _ in range(population_size):
        individual = list(range(num_vertices))
        random.shuffle(individual)
        population.append(individual)
    return population

def genetic_algorithm_space_complexity(population_size, num_vertices):
    # Estimate space complexity based on data structures
    # Space complexity for population: O(population_size * num_vertices)
    space_complexity = population_size * num_vertices
    return space_complexity

# Define the range of problem sizes (number of vertices)
problem_sizes = list(range(5, 101, 5))  # From 5 to 100 vertices, incrementing by 5

# Define the population size for the GA
population_size = 100

# Calculate space complexity for each problem size
space_complexities = [genetic_algorithm_space_complexity(population_size, num_vertices) for num_vertices in problem_sizes]

# Plotting the space complexity graph
plt.figure(figsize=(10, 6))
plt.plot(problem_sizes, space_complexities, marker='o', linestyle='-', color='b')
plt.title('Space Complexity of Genetic Algorithm for Hamiltonian Circuit')
plt.xlabel('Number of Vertices')
plt.ylabel('Space Complexity')
plt.grid(True)
plt.tight_layout()
plt.show()

import random
import matplotlib.pyplot as plt

# SA Algorithm Parameters
num_iterations = 50

# Define the graph
graph = {
    'A': {'B': True, 'C': True, 'D': True},
    'B': {'A': True, 'C': True, 'D': True},
    'C': {'A': True, 'B': True, 'D': True},
    'D': {'A': True, 'B': True, 'C': True}
}

# Function to generate a random solution
def generate_random_solution(graph):
    return random.sample(list(graph.keys()), len(graph))

# Function to calculate the time complexity for each iteration
def calculate_time_complexity(iteration):
    # Generate a random solution
    solution = generate_random_solution(graph)
    time_complexity = 1  # Count the time for generating the initial solution

    # Annealing Process
    for _ in range(iteration):
        neighbor_solution = generate_random_solution(graph)  # Generate a neighboring solution
        # Perform other operations (objective function evaluation, acceptance probability, temperature update, etc.)
        time_complexity += 1

    return time_complexity

# Calculate time complexity for each iteration
time_complexity_data = [calculate_time_complexity(iteration) for iteration in range(num_iterations)]

# Plot the time complexity graph
plt.plot(range(num_iterations), time_complexity_data)
plt.xlabel('Iteration')
plt.ylabel('Time Complexity')
plt.title('Time Complexity of Simulated Annealing for Hamiltonian Circuit')
plt.ylim(0, 200)
plt.show()

import matplotlib.pyplot as plt
import networkx as nx
import random

# Define the graph
G = nx.Graph()
G.add_nodes_from(['A', 'B', 'C', 'D'])
G.add_edges_from([('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')])

# Current solution
current_solution = ['A', 'B', 'C', 'D']

# Generate a neighboring solution by swapping two vertices
neighbor_solution = current_solution[:]
i, j = random.sample(range(len(neighbor_solution)), 2)
neighbor_solution[i], neighbor_solution[j] = neighbor_solution[j], neighbor_solution[i]

# Plot the graph with current and neighbor solutions
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)
nx.draw_networkx_nodes(G, pos, nodelist=current_solution, node_color='red', node_size=700)
nx.draw_networkx_nodes(G, pos, nodelist=neighbor_solution, node_color='green', node_size=700)
plt.title('Neighborhood Exploration Example')
plt.show()

import matplotlib.pyplot as plt
import networkx as nx

# Define the graph with weights
G = nx.Graph()
edges_with_weights = [('A', 'B', 3), ('A', 'C', 5), ('A', 'D', 2), ('B', 'C', 4), ('B', 'D', 6), ('C', 'D', 7)]
G.add_weighted_edges_from(edges_with_weights)

# Plot the graph
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)
nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): d['weight'] for u, v, d in G.edges(data=True)})
plt.title('Graph Example')
plt.show()

# Plot the initial solution (Hamiltonian circuit)
initial_solution = ['A', 'B', 'C', 'D', 'A']
nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)
nx.draw_networkx_edges(G, pos, edgelist=[(initial_solution[i], initial_solution[i+1]) for i in range(len(initial_solution)-1)], width=2, edge_color='red')
nx.draw_networkx_edge_labels(G, pos, edge_labels={(initial_solution[i], initial_solution[i+1]): G[initial_solution[i]][initial_solution[i+1]]['weight'] for i in range(len(initial_solution)-1)})
plt.title('Initial Solution Example')
plt.show()

import matplotlib.pyplot as plt
import networkx as nx
import random

# Define the graph
G = nx.Graph()
G.add_nodes_from(['A', 'B', 'C', 'D'])
G.add_edges_from([('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')])

# Define the current solution
current_solution = ['A', 'B', 'C', 'D', 'A']

# Generate a neighboring solution by randomly swapping two vertices
neighbor_solution = current_solution[:]
i, j = random.sample(range(len(neighbor_solution)), 2)
neighbor_solution[i], neighbor_solution[j] = neighbor_solution[j], neighbor_solution[i]

# Plot the graph with the current and neighboring solutions
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)
nx.draw_networkx_nodes(G, pos, nodelist=current_solution, node_color='red', node_size=700)
nx.draw_networkx_nodes(G, pos, nodelist=neighbor_solution, node_color='green', node_size=700)
plt.title('Neighborhood Exploration Example')
plt.show()

import matplotlib.pyplot as plt
import networkx as nx
import random

# Define the graph
G = nx.Graph()
G.add_nodes_from(['A', 'B', 'C', 'D'])
G.add_edges_from([('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')])

# Define the current solution
current_solution = ['A', 'B', 'C', 'D', 'A']

# Generate a neighboring solution by randomly swapping two vertices
neighbor_solution = current_solution[:]
i, j = random.sample(range(len(neighbor_solution)), 2)
neighbor_solution[i], neighbor_solution[j] = neighbor_solution[j], neighbor_solution[i]

# Plot the graph with only the edges of the current and neighboring solutions highlighted
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)

# Highlight edges of the current solution in red
current_edges = [(current_solution[k], current_solution[k+1]) for k in range(len(current_solution)-1)]
nx.draw_networkx_edges(G, pos, edgelist=current_edges, width=2, edge_color='red')

# Highlight edges of the neighboring solution in green
neighbor_edges = [(neighbor_solution[k], neighbor_solution[k+1]) for k in range(len(neighbor_solution)-1)]
nx.draw_networkx_edges(G, pos, edgelist=neighbor_edges, width=2, edge_color='green')

plt.title('Neighborhood Exploration Example')
plt.show()

import matplotlib.pyplot as plt
import networkx as nx
import random

# Define the graph
G = nx.Graph()
G.add_nodes_from(['A', 'B', 'C', 'D'])
G.add_edges_from([('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')])

# Define the initial solution as the current solution
current_solution = ['A', 'B', 'C', 'D', 'A']

# Generate a neighboring solution by randomly swapping two vertices
neighbor_solution = current_solution[:]
i, j = random.sample(range(1, len(neighbor_solution)-1), 2)  # Avoid swapping the first and last vertices
neighbor_solution[i], neighbor_solution[j] = neighbor_solution[j], neighbor_solution[i]

# Plot the graph with only the edges of the current and neighboring solutions highlighted
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)

# Highlight edges of the current solution in red
current_edges = [(current_solution[k], current_solution[k+1]) for k in range(len(current_solution)-1)]
nx.draw_networkx_edges(G, pos, edgelist=current_edges, width=2, edge_color='red')

# Highlight edges of the neighboring solution in green
neighbor_edges = [(neighbor_solution[k], neighbor_solution[k+1]) for k in range(len(neighbor_solution)-1)]
nx.draw_networkx_edges(G, pos, edgelist=neighbor_edges, width=2, edge_color='green')

plt.title('Neighborhood Exploration Example')
plt.show()

import matplotlib.pyplot as plt
import networkx as nx
import random

# Define the graph
G = nx.Graph()
G.add_nodes_from(['A', 'B', 'C', 'D'])
G.add_edges_from([('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')])

# Define the current solution
current_solution = ['A', 'B', 'C', 'D', 'A']

# Generate a neighboring solution by randomly swapping two vertices
neighbor_solution = current_solution[:]
i, j = random.sample(range(1, len(neighbor_solution)-1), 2)  # Avoid swapping the first and last vertices
neighbor_solution[i], neighbor_solution[j] = neighbor_solution[j], neighbor_solution[i]

# Calculate the quality of the current and neighboring solutions (simple objective function)
current_quality = len(current_solution) - 1  # Number of edges in the current solution
neighbor_quality = len(neighbor_solution) - 1  # Number of edges in the neighboring solution

# Plot the graph with only the edges of the current and neighboring solutions highlighted
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)

# Highlight edges of the current solution in red
current_edges = [(current_solution[k], current_solution[k+1]) for k in range(len(current_solution)-1)]
nx.draw_networkx_edges(G, pos, edgelist=current_edges, width=2, edge_color='red')

# Highlight edges of the neighboring solution in green
neighbor_edges = [(neighbor_solution[k], neighbor_solution[k+1]) for k in range(len(neighbor_solution)-1)]
nx.draw_networkx_edges(G, pos, edgelist=neighbor_edges, width=2, edge_color='green')

plt.title('Evaluation Example\nCurrent Quality: {} | Neighbor Quality: {}'.format(current_quality, neighbor_quality))
plt.show()

#new step 2

import matplotlib.pyplot as plt
import networkx as nx
import random

# Define the graph
G = nx.Graph()
G.add_nodes_from(['A', 'B', 'C', 'D'])
G.add_edges_from([('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')])

# Define the current solution as a valid Hamiltonian circuit
current_solution = ['A', 'B', 'C', 'D', 'A']

# Generate a neighboring solution by randomly swapping two vertices
neighbor_solution = current_solution[:]
i, j = random.sample(range(1, len(neighbor_solution)-1), 2)  # Avoid swapping the first and last vertices
neighbor_solution[i], neighbor_solution[j] = neighbor_solution[j], neighbor_solution[i]

# Calculate the quality of the current and neighboring solutions (simple objective function)
current_quality = len(current_solution) - 1  # Number of edges in the current solution
neighbor_quality = len(neighbor_solution) - 1  # Number of edges in the neighboring solution

# Plot the graph with only the edges of the current and neighboring solutions highlighted
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)

# Highlight edges of the current solution in red
current_edges = [(current_solution[k], current_solution[k+1]) for k in range(len(current_solution)-1)]
current_edges.append((current_solution[-1], current_solution[0]))  # Closing edge
nx.draw_networkx_edges(G, pos, edgelist=current_edges, width=2, edge_color='red')

# Highlight edges of the neighboring solution in green
neighbor_edges = [(neighbor_solution[k], neighbor_solution[k+1]) for k in range(len(neighbor_solution)-1)]
neighbor_edges.append((neighbor_solution[-1], neighbor_solution[0]))  # Closing edge
nx.draw_networkx_edges(G, pos, edgelist=neighbor_edges, width=2, edge_color='green')

plt.title('Evaluation Example\nCurrent Quality: {} | Neighbor Quality: {}'.format(current_quality, neighbor_quality))
plt.show()

import matplotlib.pyplot as plt
import networkx as nx
import random

# Define the graph
G = nx.Graph()
G.add_nodes_from(['A', 'B', 'C', 'D'])
G.add_edges_from([('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')])

# Define the current solution as a valid Hamiltonian circuit
current_solution = ['A', 'B', 'C', 'D', 'A']

# Generate a neighboring solution by randomly swapping two vertices
neighbor_solution = current_solution[:]
i, j = random.sample(range(1, len(neighbor_solution)-1), 2)  # Avoid swapping the first and last vertices
neighbor_solution[i], neighbor_solution[j] = neighbor_solution[j], neighbor_solution[i]

# Calculate the quality of the current and neighboring solutions (simple objective function)
current_quality = len(current_solution) - 1  # Number of edges in the current solution
neighbor_quality = len(neighbor_solution) - 1  # Number of edges in the neighboring solution

# Plot the graph with only the edges of the current and neighboring solutions highlighted
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)

# Highlight edges of the current solution in red
current_edges = [(current_solution[k], current_solution[k+1]) for k in range(len(current_solution)-1)]
current_edges.append((current_solution[-1], current_solution[0]))  # Closing edge
nx.draw_networkx_edges(G, pos, edgelist=current_edges, width=2, edge_color='red')

# Highlight edges of the neighboring solution in green
neighbor_edges = [(neighbor_solution[k], neighbor_solution[k+1]) for k in range(len(neighbor_solution)-1)]
neighbor_edges.append((neighbor_solution[-1], neighbor_solution[0]))  # Closing edge
nx.draw_networkx_edges(G, pos, edgelist=neighbor_edges, width=2, edge_color='green')

plt.title('Evaluation Example\nCurrent Quality: {} | Neighbor Quality: {}'.format(current_quality, neighbor_quality))
plt.show()

import matplotlib.pyplot as plt
import networkx as nx
import random

# Define the graph with weights
G = nx.Graph()
edges_with_weights = [('A', 'B', 3), ('A', 'C', 5), ('A', 'D', 2), ('B', 'C', 4), ('B', 'D', 6), ('C', 'D', 7)]
G.add_weighted_edges_from(edges_with_weights)

# Define the current solution as a valid Hamiltonian circuit
current_solution = ['A', 'B', 'C', 'D', 'A']

# Generate a neighboring solution by randomly swapping two vertices
neighbor_solution = current_solution[:]
i, j = random.sample(range(1, len(neighbor_solution)-1), 2)  # Avoid swapping the first and last vertices
neighbor_solution[i], neighbor_solution[j] = neighbor_solution[j], neighbor_solution[i]

# Calculate the quality of the current and neighboring solutions (simple objective function)
current_quality = len(current_solution) - 1  # Number of edges in the current solution
neighbor_quality = len(neighbor_solution) - 1  # Number of edges in the neighboring solution

# Plot the graph with only the edges of the current and neighboring solutions highlighted
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)

# Highlight edges of the current solution in red
current_edges = [(current_solution[k], current_solution[k+1]) for k in range(len(current_solution)-1)]
current_edges.append((current_solution[-1], current_solution[0]))  # Closing edge
nx.draw_networkx_edges(G, pos, edgelist=current_edges, width=2, edge_color='red')

# Highlight edges of the neighboring solution in green
neighbor_edges = [(neighbor_solution[k], neighbor_solution[k+1]) for k in range(len(neighbor_solution)-1)]
neighbor_edges.append((neighbor_solution[-1], neighbor_solution[0]))  # Closing edge
nx.draw_networkx_edges(G, pos, edgelist=neighbor_edges, width=2, edge_color='green')

# Add edge labels with weights
nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): d['weight'] for u, v, d in G.edges(data=True)})

plt.title('Evaluation Example\nCurrent Quality: {} | Neighbor Quality: {}'.format(current_quality, neighbor_quality))
plt.show()

import matplotlib.pyplot as plt
import networkx as nx
import random

# Define the graph
G = nx.Graph()
G.add_nodes_from(['A', 'B', 'C', 'D'])
G.add_edges_from([('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')])

# Define the population of solutions (each solution represented as a Hamiltonian circuit)
population = [['A', 'B', 'C', 'D', 'A'], ['A', 'D', 'C', 'B', 'A'], ['A', 'C', 'D', 'B', 'A']]

# Calculate the fitness scores of each solution (simple objective function)
fitness_scores = [len(solution) - 1 for solution in population]

# Sort the population based on fitness scores (descending order)
sorted_population = [x for _, x in sorted(zip(fitness_scores, population), reverse=True)]

# Plot the graph with only the edges of the best solution highlighted in red
best_solution = sorted_population[0]
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)
best_edges = [(best_solution[k], best_solution[k+1]) for k in range(len(best_solution)-1)]
best_edges.append((best_solution[-1], best_solution[0]))  # Closing edge
nx.draw_networkx_edges(G, pos, edgelist=best_edges, width=2, edge_color='red')

plt.title('Selection Example\nBest Solution: {}'.format(best_solution))
plt.show()

import matplotlib.pyplot as plt
import networkx as nx
import random

# Define the graph with weights
G = nx.Graph()
edges_with_weights = [('A', 'B', 3), ('A', 'C', 5), ('A', 'D', 2), ('B', 'C', 4), ('B', 'D', 6), ('C', 'D', 7)]
G.add_weighted_edges_from(edges_with_weights)

# Define the population of solutions (each solution represented as a Hamiltonian circuit)
population = [['A', 'B', 'C', 'D', 'A'], ['A', 'D', 'C', 'B', 'A'], ['A', 'C', 'D', 'B', 'A']]

# Calculate the fitness scores of each solution (simple objective function)
fitness_scores = [len(solution) - 1 for solution in population]

# Sort the population based on fitness scores (descending order)
sorted_population = [x for _, x in sorted(zip(fitness_scores, population), reverse=True)]

# Plot the graph with only the edges of the best solution highlighted in red
best_solution = sorted_population[0]
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=700, font_size=12)
best_edges = [(best_solution[k], best_solution[k+1]) for k in range(len(best_solution)-1)]
best_edges.append((best_solution[-1], best_solution[0]))  # Closing edge
nx.draw_networkx_edges(G, pos, edgelist=best_edges, width=2, edge_color='red')

# Add edge labels with weights
nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): d['weight'] for u, v, d in G.edges(data=True)})

plt.title('Selection Example\nBest Solution: {}'.format(best_solution))
plt.show()

def generate_adjacency_matrix(n):
    return [[0] * n for _ in range(n)]

def generate_adjacency_list(n):
    return [[] for _ in range(n)]

# Example parameters
num_vertices = 5

# Generate adjacency matrix and adjacency list
adj_matrix = generate_adjacency_matrix(num_vertices)
adj_list = generate_adjacency_list(num_vertices)

# Print the adjacency matrix
print("Adjacency Matrix:")
for row in adj_matrix:
    print(row)

# Print the adjacency list
print("\nAdjacency List:")
for i, adj in enumerate(adj_list):
    print(f"Vertex {i+1}: {adj}")

import random
  import time
  import matplotlib.pyplot as plt

  # SA Algorithm Parameters
  num_iterations = 50

  # Define the graph
  graph = {
      'A': {'B': True, 'C': True, 'D': True},
      'B': {'A': True, 'C': True, 'D': True},
      'C': {'A': True, 'B': True, 'D': True},
      'D': {'A': True, 'B': True, 'C': True}
  }

  # Function to generate a random solution
  def generate_random_solution(graph):
      return random.sample(list(graph.keys()), len(graph))

  # Function to calculate the time complexity for each iteration
  def calculate_time_complexity(iteration):
      start_time = time.time()
      # Generate a random solution
      solution = generate_random_solution(graph)
      # Annealing Process
      for _ in range(iteration):
          neighbor_solution = generate_random_solution(graph)  # Generate a neighboring solution
      end_time = time.time()
      return end_time - start_time

  # Calculate time complexity for each iteration
  time_complexity_data = [calculate_time_complexity(iteration) for iteration in range(num_iterations)]

  # Plot the time complexity graph
  plt.plot(range(num_iterations), time_complexity_data)
  plt.xlabel('Iteration')
  plt.ylabel('Time Complexity (seconds)')
  plt.title('Time Complexity of Simulated Annealing for Hamiltonian Circuit')
  # plt.ylim(0, 0.016)
  plt.show()

#Time Complexity for GA

import random
import time
import matplotlib.pyplot as plt

# Genetic Algorithm Parameters
population_size = 50
num_generations = 50
mutation_rate = 0.1

# Define the graph
graph = {
    'A': {'B': True, 'C': True, 'D': True},
    'B': {'A': True, 'C': True, 'D': True},
    'C': {'A': True, 'B': True, 'D': True},
    'D': {'A': True, 'B': True, 'C': True}
}

# Function to generate initial population
def generate_initial_population(population_size, graph):
    return [random.sample(list(graph.keys()), len(graph)) for _ in range(population_size)]

# Objective function (fitness function)
def objective_function(chromosome, graph):
    # Check if the chromosome forms a Hamiltonian circuit
    if set(chromosome) == set(graph.keys()) and graph[chromosome[-1]][chromosome[0]]:
        return 1
    else:
        return 0

# Selection function (roulette wheel selection)
def selection(population, graph):
    fitness_scores = [objective_function(chromosome, graph) for chromosome in population]
    total_fitness = sum(fitness_scores)
    probabilities = [score / total_fitness for score in fitness_scores]
    selected_indices = random.choices(range(len(population)), weights=probabilities, k=len(population))
    return [population[idx] for idx in selected_indices]

# Crossover function (single-point crossover)
def crossover(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 1)
    child1 = parent1[:crossover_point] + [gene for gene in parent2 if gene not in parent1[:crossover_point]]
    child2 = parent2[:crossover_point] + [gene for gene in parent1 if gene not in parent2[:crossover_point]]
    return child1, child2

# Mutation function (random mutation)
def mutate(chromosome, mutation_rate):
    mutated_chromosome = chromosome[:]
    for i in range(len(chromosome)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(chromosome) - 1)
            mutated_chromosome[i], mutated_chromosome[j] = mutated_chromosome[j], mutated_chromosome[i]
    return mutated_chromosome

# Calculate the time complexity for each generation
time_complexity = []

for generation in range(num_generations):
    start_time = time.time()

    # Generate initial population
    population = generate_initial_population(population_size, graph)

    # Selection
    selected_population = selection(population, graph)

    # Crossover and Mutation
    offspring = []
    while len(offspring) < population_size:
        parent1, parent2 = random.sample(selected_population, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, mutation_rate)
        child2 = mutate(child2, mutation_rate)
        offspring.extend([child1, child2])

    # Replacement
    population = offspring

    end_time = time.time()
    time_complexity.append(end_time - start_time)

# Plot the time complexity graph
plt.plot(range(num_generations), time_complexity)
plt.xlabel('Generation')
plt.ylabel('Time Complexity (seconds)')
plt.title('Time Complexity of Genetic Algorithm for Hamiltonian Circuit')
# plt.ylim(0, 0.016)
plt.show()



import matplotlib.pyplot as plt
import numpy as np
import heapq

def generate_random_coordinates(num_cities, min_coord=0, max_coord=10):
    return np.random.uniform(min_coord, max_coord, size=(num_cities, 2))

def euclidean_distance(city1, city2):
    return np.sqrt((city1[0] - city2[0]) ** 2 + (city1[1] - city2[1]) ** 2)

def closest_insertion_space_complexity(num_cities):
    # Space complexity for storing the coordinates of cities
    coordinates_space_complexity = num_cities * 2 * 8  # Assuming 8 bytes per coordinate (64-bit float)
    # Space complexity for the heap (priority queue) to find the closest city
    heap_space_complexity = num_cities * 8  # Assuming 8 bytes per element (64-bit float)
    # Space complexity for storing the tour
    tour_space_complexity = num_cities * 4  # Assuming 4 bytes per index (32-bit integer)
    # Non-linear term
    nonlinear_term = num_cities ** 2  # Quadratic term

    # Total space complexity (including the non-linear term)
    total_space_complexity = coordinates_space_complexity + heap_space_complexity + tour_space_complexity + nonlinear_term
    return total_space_complexity

# Define the range of problem sizes (number of cities)
problem_sizes = list(range(5, 101, 5))  # From 5 to 100 cities, incrementing by 5

# Calculate space complexity for each problem size
space_complexities = [closest_insertion_space_complexity(num_cities) for num_cities in problem_sizes]

# Plotting the space complexity graph
plt.figure(figsize=(10, 6))
plt.plot(problem_sizes, space_complexities, marker='o', color='b')
plt.title('Space Complexity of Closest Insertion Algorithm with Heap for TSP')
plt.xlabel('Number of Cities')
plt.ylabel('Space Complexity (bytes)')
plt.grid(True)
plt.tight_layout()
plt.show()

