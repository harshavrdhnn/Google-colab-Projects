# -*- coding: utf-8 -*-
"""MaxFlow_MinCut_25_04ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17d2R1JaoxkvcRJPlKAS8FwWyzMuWteQy
"""

import time
import matplotlib.pyplot as plt

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0] * vertices for _ in range(vertices)]

    def add_edge(self, u, v, capacity):
        self.graph[u][v] = capacity

    # Dinic's algorithm implementation
    # Methods for finding augmenting paths and updating flow would be here

def analyze_time_complexity(max_vertices):
    input_sizes = list(range(1, max_vertices + 1))
    execution_times = []

    for vertices in input_sizes:
        g = Graph(vertices)
        for i in range(vertices - 1):
            g.add_edge(i, i + 1, 1)
        # Add other edges as needed
        # Perform Dinic's algorithm and measure execution time
        start_time = time.time()
        # Execute Dinic's algorithm here
        end_time = time.time()
        execution_time = end_time - start_time
        execution_times.append(execution_time)

    return input_sizes, execution_times

if __name__ == "__main__":
    max_vertices = 20
    input_sizes, execution_times = analyze_time_complexity(max_vertices)

    plt.plot(input_sizes, execution_times, marker='o', linestyle='-')
    plt.xlabel('Number of Vertices')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Time Complexity Analysis of Dinic\'s Algorithm')
    plt.grid(True)
    plt.show()

import matplotlib.pyplot as plt

class DinicsGraph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[] for _ in range(vertices)]
        self.distance = [-1] * vertices

    def add_edge(self, u, v, capacity):
        self.graph[u].append({'v': v, 'capacity': capacity, 'flow': 0})

    def space_complexity_analysis(self):
        space_components = {
            "Graph Adjacency List": self.V + sum(len(adj) for adj in self.graph),
            "Distance/Level Array": self.V,
            "Flow Network": self.V**2  # Optional, if maintained separately
        }
        return space_components

    def plot_space_complexity(self):
        space_components = self.space_complexity_analysis()
        labels = space_components.keys()
        sizes = space_components.values()

        plt.bar(labels, sizes)
        plt.xlabel('Space Components')
        plt.ylabel('Space Required')
        plt.title("Space Complexity Analysis of Dinic's Algorithm")
        plt.xticks(rotation=45, ha='right')
        plt.show()

if __name__ == "__main__":
    g = DinicsGraph(6)
    g.add_edge(0, 1, 16)
    g.add_edge(0, 2, 13)
    g.add_edge(1, 2, 10)
    g.add_edge(1, 3, 12)
    g.add_edge(2, 1, 4)
    g.add_edge(2, 4, 14)
    g.add_edge(3, 2, 9)
    g.add_edge(3, 5, 20)
    g.add_edge(4, 3, 7)
    g.add_edge(4, 5, 4)

    g.plot_space_complexity()

import networkx as nx
import matplotlib.pyplot as plt

class FordFulkerson:
    def __init__(self, graph):
        self.graph = graph

    def findMaxFlow(self, source, sink):
        maxFlow = 0
        while True:
            augmentingPath, bottleneckCapacity = self.dfs(source, sink, set())
            if augmentingPath is None:
                break
            maxFlow += bottleneckCapacity
            self.updateResidualCapacities(augmentingPath, bottleneckCapacity)
            self.drawGraphWithHighlightedPath(augmentingPath, maxFlow)
        return maxFlow

    def dfs(self, u, sink, visited):
        visited.add(u)
        if u == sink:
            return [], float('inf')
        for v, capacity in self.graph[u].items():
            if v not in visited and capacity > 0:
                path, minCapacity = self.dfs(v, sink, visited)
                if path is not None:
                    return [(u, v)] + path, min(capacity, minCapacity)
        return None, 0

    def updateResidualCapacities(self, augmentingPath, bottleneckCapacity):
        for u, v in augmentingPath:
            self.graph[u][v] -= bottleneckCapacity
            self.graph[v][u] = self.graph.get(v, {}).get(u, 0) + bottleneckCapacity

    def drawGraphWithHighlightedPath(self, augmentingPath, maxFlow):
        G = nx.DiGraph()
        for u, edges in self.graph.items():
            for v, capacity in edges.items():
                if capacity > 0:
                    G.add_edge(u, v, capacity=capacity)
        pos = nx.spring_layout(G)
        edge_labels = {(u, v): str(min(self.graph[u][v], self.graph[v].get(u, 0))) for (u, v) in G.edges()}
        nx.draw(G, pos, with_labels=True, font_weight='bold', node_color='skyblue', node_size=1500)
        nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5, edge_color='lightgray')
        nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)
        if augmentingPath:
            augmenting_edges = augmentingPath
            nx.draw_networkx_edges(G, pos, edgelist=augmenting_edges, width=2, edge_color='red')
        plt.title("Path Highlighted for Max Flow: {}".format(maxFlow))
        plt.show()

# Example usage:
graph = {
    's': {'A': 10},
    'A': {'C': 5, 'B': 10},
    'B': {'D': 10},
    'C': {'t': 5},
    'D': {'t': 5},
    't': {}
}

fordFulkerson = FordFulkerson(graph)
maxFlow = fordFulkerson.findMaxFlow('s', 't')
print("Maximum Flow:", maxFlow)

import networkx as nx
import matplotlib.pyplot as plt
import sys

class FordFulkersonSpaceComplexity:
    def __init__(self):
        self.visited_set_size = []
        self.queue_size = []
        self.residual_graph_size = []

    def create_residual_graph(self, graph):
        residual_graph = {node: {} for node in graph}
        for u, edges in graph.items():
            for v, capacity in edges.items():
                residual_graph[u][v] = capacity
                residual_graph[v][u] = 0
        return residual_graph

    def find_augmenting_path(self, source, sink, graph):
        visited_set = set()
        queue = []
        visited_set.add(source)
        queue.append((source, []))
        while queue:
            u, path = queue.pop(0)
            if u == sink:
                return path, self.find_bottleneck_capacity(path, graph)
            for v, capacity in graph[u].items():
                if v not in visited_set and capacity > 0:
                    new_path = path + [v]
                    visited_set.add(v)
                    queue.append((v, new_path))
        return None, 0

    def find_bottleneck_capacity(self, path, graph):
        bottleneck_capacity = float('inf')
        for i in range(len(path) - 1):
            u, v = path[i], path[i + 1]
            bottleneck_capacity = min(bottleneck_capacity, graph[u][v])
        return bottleneck_capacity

    def update_residual_capacities(self, augmenting_path, bottleneck_capacity, graph):
        for i in range(len(augmenting_path) - 1):
            u, v = augmenting_path[i], augmenting_path[i + 1]
            graph[u][v] -= bottleneck_capacity
            graph[v][u] += bottleneck_capacity

    def ford_fulkerson(self, source, sink, graph):
        max_flow = 0
        while True:
            augmenting_path, bottleneck_capacity = self.find_augmenting_path(source, sink, graph)
            if augmenting_path is None:
                break
            max_flow += bottleneck_capacity
            self.update_residual_capacities(augmenting_path, bottleneck_capacity, graph)
            # Measure space complexity
            self.visited_set_size.append(sys.getsizeof(self.visited_set_size))
            self.queue_size.append(sys.getsizeof(self.queue_size))
            self.residual_graph_size.append(sys.getsizeof(graph))
        return max_flow

# Function to generate a sample graph
def generate_graph(num_vertices):
    graph = {}
    for i in range(num_vertices):
        graph[str(i)] = {}
        for j in range(num_vertices):
            if i != j:
                graph[str(i)][str(j)] = 1  # Adding arbitrary capacity for edges
    return graph

# Plotting the space complexity graph
def plot_space_complexity(num_vertices_list):
    space_complexity = FordFulkersonSpaceComplexity()
    max_flow_list = []

    for num_vertices in num_vertices_list:
        graph = generate_graph(num_vertices)
        max_flow = space_complexity.ford_fulkerson('0', str(num_vertices - 1), graph)
        max_flow_list.append(max_flow)

    plt.plot(num_vertices_list, space_complexity.visited_set_size, label='Visited Set Size')
    plt.plot(num_vertices_list, space_complexity.queue_size, label='Queue Size')
    plt.plot(num_vertices_list, space_complexity.residual_graph_size, label='Residual Graph Size')
    plt.xlabel('Number of Vertices')
    plt.ylabel('Space Complexity')
    plt.title('Space Complexity of Ford-Fulkerson Algorithm')
    plt.legend()
    plt.show()

# Example usage
num_vertices_list = [10, 20, 30, 40, 50]
plot_space_complexity(num_vertices_list)

import matplotlib.pyplot as plt

def ford_fulkerson_space_complexity(num_vertices):
    # Space complexity for augmenting path search (BFS)
    bfs_space_complexity = num_vertices + (num_vertices**2)  # O(V + E)
    # Space complexity for bottleneck capacity calculation
    bottleneck_space_complexity = 1  # O(1)
    # Space complexity for residual capacities update
    residual_space_complexity = num_vertices + (num_vertices**2)  # O(V + E)

    # Total space complexity
    total_space_complexity = bfs_space_complexity + bottleneck_space_complexity + residual_space_complexity
    return total_space_complexity

# Define the range of problem sizes (number of vertices)
problem_sizes = list(range(5, 101, 5))  # From 5 to 100 vertices, incrementing by 5

# Calculate space complexity for each problem size
space_complexities = [ford_fulkerson_space_complexity(num_vertices) for num_vertices in problem_sizes]

# Plotting the space complexity graph
plt.figure(figsize=(10, 6))
plt.plot(problem_sizes, space_complexities, marker='o', linestyle='-', color='b')
plt.title('Space Complexity of Ford-Fulkerson Algorithm')
plt.xlabel('Number of Vertices')
plt.ylabel('Space Complexity')
plt.grid(True)
plt.tight_layout()
plt.show()

# ED for MfMc

import networkx as nx
import matplotlib.pyplot as plt

class EdmondsKarp:
    def __init__(self, graph):
        self.graph = graph

    def findMaxFlow(self, source, sink):
        maxFlow = 0
        while True:
            augmentingPath, bottleneckCapacity = self.bfs(source, sink)
            if augmentingPath is None:
                break
            maxFlow += bottleneckCapacity
            self.updateResidualCapacities(augmentingPath, bottleneckCapacity)
            self.drawGraphWithHighlightedPath(augmentingPath)
        return maxFlow

    def bfs(self, source, sink):
        visited = {source}
        queue = [(source, [source], float('inf'))]

        while queue:
            u, path, minCapacity = queue.pop(0)
            for v, capacity in self.graph[u].items():
                if v not in visited and capacity > 0:
                    visited.add(v)
                    newPath = path + [v]
                    newMinCapacity = min(minCapacity, capacity)
                    if v == sink:
                        return newPath, newMinCapacity
                    queue.append((v, newPath, newMinCapacity))
        return None, 0

    def updateResidualCapacities(self, augmentingPath, bottleneckCapacity):
        for i in range(len(augmentingPath) - 1):
            u, v = augmentingPath[i], augmentingPath[i + 1]
            self.graph[u][v] -= bottleneckCapacity
            self.graph[v][u] = self.graph.get(v, {}).get(u, 0) + bottleneckCapacity

    def drawGraphWithHighlightedPath(self, augmentingPath):
        G = nx.DiGraph()
        for u, edges in self.graph.items():
            for v, capacity in edges.items():
                G.add_edge(u, v, capacity=capacity)
        pos = nx.spring_layout(G)
        edge_labels = {(u, v): str(capacity) for (u, v, capacity) in G.edges(data='capacity')}
        nx.draw(G, pos, with_labels=True, font_weight='bold', node_color='skyblue', node_size=1500)
        nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5, edge_color='lightgray')
        nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)
        augmenting_edges = [(augmentingPath[i], augmentingPath[i + 1]) for i in range(len(augmentingPath) - 1)]
        nx.draw_networkx_edges(G, pos, edgelist=augmenting_edges, width=2, edge_color='red')
        plt.title("Path Highlighted")
        plt.show()

# Example usage:
graph = {
    's': {'A': 10, 'B': 5},
    'A': {'B': 15, 'C': 10},
    'B': {'D': 10},
    'C': {'t': 10},
    'D': {'C': 15, 't': 10},
    't': {}
}

edmondsKarp = EdmondsKarp(graph)
maxFlow = edmondsKarp.findMaxFlow('s', 't')
print("Maximum Flow:", maxFlow)



import networkx as nx
import matplotlib.pyplot as plt

class PushRelabel:
    def __init__(self, graph):
        self.graph = graph

    def findMaxFlow(self, source, sink):
        maxFlow = 0
        self.initializePreflow(source)
        while self.overflowVertex(source, sink):
            u = self.getOverflowVertex()
            if not self.push(u):
                self.relabel(u)
        maxFlow = sum(self.graph[sink].values())
        print("Flow into sink node:", maxFlow)
        return maxFlow

    def initializePreflow(self, source):
        self.height = {v: 0 for v in self.graph}
        self.excess = {v: 0 for v in self.graph}
        self.height[source] = len(self.graph)
        for v, capacity in self.graph[source].items():
            self.excess[v] = capacity
            self.excess[source] -= capacity

    def overflowVertex(self, source, sink):
        return any(self.excess[v] > 0 and v != source and v != sink for v in self.graph)

    def getOverflowVertex(self):
        for v in self.graph:
            if self.excess[v] > 0:
                return v

    def push(self, u):
        for v, capacity in self.graph[u].items():
            if self.height[u] == self.height[v] + 1 and capacity > 0:
                flow = min(self.excess[u], capacity)
                self.graph[u][v] -= flow
                if v not in self.graph:
                    self.graph[v] = {}
                self.graph[v][u] = self.graph[v].get(u, 0) + flow  # Create reverse edge if not exist
                self.excess[u] -= flow
                self.excess[v] += flow
                return True
        return False

    def relabel(self, u):
        self.height[u] = min([self.height[v] for v in self.graph[u] if self.graph[u][v] > 0]) + 1

    def findAugmentingPaths(self, source, sink):
        visited = {v: False for v in self.graph}
        paths = []
        self.dfs(source, sink, visited, [], paths)
        return paths

    def dfs(self, u, sink, visited, path, paths):
        visited[u] = True
        path.append(u)
        if u == sink:
            paths.append(path.copy())
        else:
            for v, capacity in self.graph[u].items():
                if capacity > 0 and not visited[v]:
                    self.dfs(v, sink, visited, path, paths)
        path.pop()
        visited[u] = False

    def drawGraphWithHighlightedPaths(self, source, sink, paths):
        G = nx.DiGraph()
        for u, edges in self.graph.items():
            for v, capacity in edges.items():
                G.add_edge(u, v, capacity=capacity)
        pos = nx.spring_layout(G)
        edge_labels = {(u, v): str(capacity) for (u, v, capacity) in G.edges(data='capacity')}
        nx.draw(G, pos, with_labels=True, font_weight='bold', node_color='skyblue', node_size=1500)
        nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5, edge_color='lightgray')
        nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)
        for path in paths:
            for u, v in zip(path[:-1], path[1:]):
                nx.draw_networkx_edges(G, pos, edgelist=[(u, v)], width=2, edge_color='red')
        plt.title("Paths Highlighted")
        plt.show()

# Example usage:
graph = {
    's': {'A': 10, 'B': 5},
    'A': {'B': 15, 'C': 10},
    'B': {'D': 10},
    'C': {'t': 10},
    'D': {'C': 15, 't': 10},
    't': {}
}

pushRelabel = PushRelabel(graph)
maxFlow = pushRelabel.findMaxFlow('s', 't')
print("Maximum Flow:", maxFlow)

augmentingPaths = pushRelabel.findAugmentingPaths('s', 't')
pushRelabel.drawGraphWithHighlightedPaths('s', 't', augmentingPaths)

#Edmands Space

import matplotlib.pyplot as plt

def edmonds_karp_space_complexity(num_vertices):
    # Space complexity for augmenting path search (BFS)
    bfs_space_complexity = num_vertices**2  # O(V^2)
    # Space complexity for bottleneck capacity calculation
    bottleneck_space_complexity = 1  # O(1)
    # Space complexity for residual capacities update
    residual_space_complexity = num_vertices**2  # O(V^2)

    # Total space complexity
    total_space_complexity = bfs_space_complexity + bottleneck_space_complexity + residual_space_complexity
    return total_space_complexity

# Define the range of problem sizes (number of vertices)
problem_sizes = list(range(5, 101, 5))  # From 5 to 100 vertices, incrementing by 5

# Calculate space complexity for each problem size
space_complexities = [edmonds_karp_space_complexity(num_vertices) for num_vertices in problem_sizes]

# Plotting the space complexity graph
plt.figure(figsize=(10, 6))
plt.plot(problem_sizes, space_complexities, marker='o', linestyle='-', color='b')
plt.title('Space Complexity of Edmonds-Karp Algorithm')
plt.xlabel('Number of Vertices')
plt.ylabel('Space Complexity')
plt.grid(True)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

def bfs(graph, source, sink, parent):
    visited = [False] * len(graph)
    queue = []
    queue.append(source)
    visited[source] = True

    while queue:
        u = queue.pop(0)
        for v, capacity in enumerate(graph[u]):
            if not visited[v] and capacity > 0:
                queue.append(v)
                visited[v] = True
                parent[v] = u
    return visited[sink]

def edmonds_karp(graph, source, sink):
    parent = [-1] * len(graph)
    max_flow = 0

    while bfs(graph, source, sink, parent):
        path_flow = float("inf")
        s = sink
        while s != source:
            path_flow = min(path_flow, graph[parent[s]][s])
            s = parent[s]

        max_flow += path_flow
        v = sink
        while v != source:
            u = parent[v]
            graph[u][v] -= path_flow
            graph[v][u] += path_flow
            v = parent[v]

    return max_flow

def edmonds_karp_space_complexity(num_vertices):
    # Space complexity for augmenting path search (BFS)
    bfs_space_complexity = num_vertices ** 2  # O(V^2)
    # Space complexity for bottleneck capacity calculation
    bottleneck_space_complexity = 1  # O(1)
    # Space complexity for residual capacities update
    residual_space_complexity = num_vertices ** 2  # O(V^2)

    # Total space complexity
    total_space_complexity = bfs_space_complexity + bottleneck_space_complexity + residual_space_complexity
    return total_space_complexity

# Define the range of problem sizes (number of vertices)
problem_sizes = list(range(5, 101, 5))  # From 5 to 100 vertices, incrementing by 5

# Calculate space complexity for each problem size
space_complexities = [edmonds_karp_space_complexity(num_vertices) for num_vertices in problem_sizes]

# Plotting the space complexity graph
plt.figure(figsize=(10, 6))
plt.plot(problem_sizes, space_complexities, marker='o', linestyle='-', color='b')
plt.title('Space Complexity of Edmonds-Karp Algorithm')
plt.xlabel('Number of Vertices')
plt.ylabel('Space Complexity')
plt.grid(True)
plt.tight_layout()
plt.show()

#edmands Time compelxity

import matplotlib.pyplot as plt

def edmonds_karp_time_complexity(num_vertices, num_edges):
    # Time complexity for BFS operations
    bfs_time_complexity = num_vertices * num_edges**2  # O(VE^2)
    # Time complexity for edge traversals in augmentations
    edge_traversal_time_complexity = num_vertices * num_edges  # O(VE)

    # Total time complexity
    total_time_complexity = bfs_time_complexity + edge_traversal_time_complexity
    return total_time_complexity

# Define the range of problem sizes (number of vertices and edges)
problem_sizes = list(range(5, 101, 5))  # From 5 to 100 vertices, incrementing by 5
num_edges = [size - 1 for size in problem_sizes]  # Assuming a connected graph

# Calculate time complexity for each problem size
time_complexities = [edmonds_karp_time_complexity(num_vertices, num_edge) for num_vertices, num_edge in zip(problem_sizes, num_edges)]

# Plotting the time complexity graph
plt.figure(figsize=(10, 6))
plt.plot(problem_sizes, time_complexities, marker='o', linestyle='-', color='b')
plt.title('Time Complexity of Edmonds-Karp Algorithm')
plt.xlabel('Number of Vertices')
plt.ylabel('Time Complexity')
plt.grid(True)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Space complexity function for Ford-Fulkerson algorithm
def ford_fulkerson_space_complexity(num_vertices):
    # Space complexity for augmenting path search (BFS)
    bfs_space_complexity = num_vertices + (num_vertices**2)  # O(V + E)
    # Space complexity for bottleneck capacity calculation
    bottleneck_space_complexity = 1  # O(1)
    # Space complexity for residual capacities update
    residual_space_complexity = num_vertices + (num_vertices**2)  # O(V + E)

    # Total space complexity
    total_space_complexity = bfs_space_complexity + bottleneck_space_complexity + residual_space_complexity
    return total_space_complexity

# Space complexity function for Edmonds-Karp algorithm
def edmonds_karp_space_complexity(num_vertices):
    # Space complexity for augmenting path search (BFS)
    bfs_space_complexity = num_vertices**2  # O(V^2)
    # Space complexity for bottleneck capacity calculation
    bottleneck_space_complexity = 1  # O(1)
    # Space complexity for residual capacities update
    residual_space_complexity = num_vertices**2  # O(V^2)

    # Total space complexity
    total_space_complexity = bfs_space_complexity + bottleneck_space_complexity + residual_space_complexity
    return total_space_complexity

# Define the range of problem sizes (number of vertices)
problem_sizes = list(range(5, 101, 5))  # From 5 to 100 vertices, incrementing by 5

# Calculate space complexity for Ford-Fulkerson algorithm
space_complexities_ford_fulkerson = [ford_fulkerson_space_complexity(num_vertices) for num_vertices in problem_sizes]

# Calculate space complexity for Edmonds-Karp algorithm
space_complexities_edmonds_karp = [edmonds_karp_space_complexity(num_vertices) for num_vertices in problem_sizes]

# Plotting the space complexity graphs
plt.figure(figsize=(12, 6))

# Plotting Ford-Fulkerson space complexity
plt.subplot(1, 2, 1)
plt.plot(problem_sizes, space_complexities_ford_fulkerson, marker='o', linestyle='-', color='b')
plt.title('Space Complexity of Ford-Fulkerson Algorithm')
plt.xlabel('Number of Vertices')
plt.ylabel('Space Complexity')
plt.grid(True)

# Annotating Ford-Fulkerson space complexities
for x, y in zip(problem_sizes, space_complexities_ford_fulkerson):
    plt.text(x, y, f'{y:.0f}', ha='center', va='bottom')

# Plotting Edmonds-Karp space complexity
plt.subplot(1, 2, 2)
plt.plot(problem_sizes, space_complexities_edmonds_karp, marker='o', linestyle='-', color='r')
plt.title('Space Complexity of Edmonds-Karp Algorithm')
plt.xlabel('Number of Vertices')
plt.ylabel('Space Complexity')
plt.grid(True)

# Annotating Edmonds-Karp space complexities
for x, y in zip(problem_sizes, space_complexities_edmonds_karp):
    plt.text(x, y, f'{y:.0f}', ha='center', va='bottom')

plt.tight_layout()
plt.show()

import time
import matplotlib.pyplot as plt

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0] * vertices for _ in range(vertices)]
        self.height = [0] * vertices
        self.excess_flow = [0] * vertices

    def add_edge(self, u, v, capacity):
        self.graph[u][v] = capacity

    def push(self, u, v):
        delta_flow = min(self.excess_flow[u], self.graph[u][v])
        self.graph[u][v] -= delta_flow
        self.graph[v][u] += delta_flow
        self.excess_flow[u] -= delta_flow
        self.excess_flow[v] += delta_flow

    def relabel(self, u):
        min_height = float('inf')
        for v in range(self.V):
            if self.graph[u][v] > 0:
                min_height = min(min_height, self.height[v])
        self.height[u] = min_height + 1

    def push_relabel(self, source, sink):
        self.height[source] = self.V
        self.excess_flow[source] = float('inf')

        start_time = time.time()  # Start time measurement

        active_nodes = [i for i in range(self.V) if i != source and i != sink]

        while active_nodes:
            u = active_nodes.pop()
            old_height = self.height[u]
            self.discharge(u)
            if self.height[u] > old_height:
                active_nodes.insert(0, u)
                active_nodes = sorted(active_nodes, key=lambda x: self.height[x])

        max_flow = sum(self.graph[source])

        end_time = time.time()  # End time measurement
        execution_time = end_time - start_time

        return max_flow, execution_time

    def discharge(self, u):
        while self.excess_flow[u] > 0:
            if len([v for v in range(self.V) if self.graph[u][v] > 0 and self.height[u] == self.height[v] + 1]) > 0:
                v = [v for v in range(self.V) if self.graph[u][v] > 0 and self.height[u] == self.height[v] + 1][0]
                self.push(u, v)
            else:
                self.relabel(u)

def analyze_time_complexity(max_vertices):
    input_sizes = list(range(1, max_vertices + 1))
    execution_times = []

    for vertices in input_sizes:
        g = Graph(vertices)
        for i in range(vertices - 1):
            g.add_edge(i, i + 1, 1)
        source = 0
        sink = vertices - 1
        _, execution_time = g.push_relabel(source, sink)
        execution_times.append(execution_time)

    return input_sizes, execution_times

if __name__ == "__main__":
    max_vertices = 20
    input_sizes, execution_times = analyze_time_complexity(max_vertices)

    plt.plot(input_sizes, execution_times, marker='o', linestyle='-')
    plt.xlabel('Number of Vertices')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Time Complexity Analysis of Push-Relabel Algorithm')
    plt.grid(True)
    plt.show()

import matplotlib.pyplot as plt

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0] * vertices for _ in range(vertices)]
        self.height = [0] * vertices
        self.excess_flow = [0] * vertices

    def add_edge(self, u, v, capacity):
        self.graph[u][v] = capacity

    def space_complexity_analysis(self):
        space_components = {
            "Graph Adjacency Matrix": self.V**2,
            "Height Array": self.V,
            "Excess Flow Array": self.V,
            "Flow Network": self.V**2  # Optional, if maintained separately
        }
        return space_components

    def plot_space_complexity(self):
        space_components = self.space_complexity_analysis()
        labels = space_components.keys()
        sizes = space_components.values()

        plt.bar(labels, sizes)
        plt.xlabel('Space Components')
        plt.ylabel('Space Required')
        plt.title('Space Complexity Analysis of Push-Relabel Algorithm')
        plt.xticks(rotation=45, ha='right')
        plt.show()

# Example usage:
if __name__ == "__main__":
    g = Graph(6)
    g.add_edge(0, 1, 16)
    g.add_edge(0, 2, 13)
    g.add_edge(1, 2, 10)
    g.add_edge(1, 3, 12)
    g.add_edge(2, 1, 4)
    g.add_edge(2, 4, 14)
    g.add_edge(3, 2, 9)
    g.add_edge(3, 5, 20)
    g.add_edge(4, 3, 7)
    g.add_edge(4, 5, 4)

    g.plot_space_complexity()

